# 백엔드 아키텍처 가이드

## 개요
본 문서는 그룹웨어 백엔드 시스템의 MSA(Microservice Architecture) 구조와 설계 원칙을 설명합니다.

## MSA 모듈 구성

### 1. common 모듈
- **특징**: 실행되지 않는 라이브러리 모듈
- **용도**: 공통 코드 및 유틸리티 제공
- **주요 구성요소**:
  - `BaseEntity`: 모든 엔티티의 기본 클래스 (생성일시, 수정일시 등)
  - `BaseDto`: 모든 DTO의 기본 클래스
  - `CommonResponse`: 표준화된 API 응답 래퍼
  - `GlobalExceptionHandler`: 전역 예외 처리
  - `GenericConverter`: 엔티티-DTO 변환 유틸리티

### 2. app-core
- **역할**: 그룹웨어 핵심 비즈니스 로직 처리
- **주요 도메인**:
  - `user`: 사용자 관리
  - `schedule`: 일정 관리
  - `newsfeed`: 뉴스피드
  - `approval`: 전자결재
  - `board`: 게시판

### 3. app.streamhub
- **역할**: 실시간 통신 처리
- **기술**: WebSocket 기반
- **주요 기능**:
  - 실시간 알림
  - 채팅
  - 실시간 상태 업데이트

## 도메인 기반 패키지 구조

각 도메인은 다음과 같은 레이어드 아키텍처를 따릅니다:

```
domain/
├── web/                    # 컨트롤러 레이어
│   └── ScheduleController.java
├── service/               # 비즈니스 로직 레이어
│   ├── ScheduleService.java        # 인터페이스
│   ├── impl/
│   │   └── ScheduleServiceImpl.java # 구현체
│   └── factory/
│       └── ScheduleServiceFactory.java
├── mapper/                # 데이터 접근 레이어
│   ├── ScheduleMapper.java         # MyBatis 인터페이스
│   └── ScheduleMapper.xml          # SQL 매핑
└── model/                 # 도메인 모델
    ├── ScheduleEntity.java         # DB 엔티티
    ├── ScheduleRequestDto.java     # 요청 DTO
    ├── ScheduleResponseDto.java    # 응답 DTO
    └── ScheduleType.java          # Enum 타입
```

## 설계 원칙

### 1. 명명 규칙
- **약어 사용 금지**: 명확한 풀네이밍 사용
  - ❌ `UsrReqDto`
  - ✅ `UserRequestDto`
- **일관된 접미사 사용**:
  - Entity: DB 테이블 매핑 클래스
  - RequestDto/ResponseDto: API 요청/응답 객체
  - Service/ServiceImpl: 서비스 인터페이스/구현체

### 2. 계층 분리
- **Controller**: HTTP 요청/응답 처리
- **Service**: 비즈니스 로직, 트랜잭션 관리
- **Mapper**: 데이터베이스 접근
- **Model**: 데이터 구조 정의

### 3. DTO-Entity 분리
- Entity는 DB 스키마와 1:1 매핑
- DTO는 API 계약을 위한 전송 객체
- Converter를 통한 변환 처리

### 4. 의존성 방향
```
Controller → Service → Mapper → Database
     ↓          ↓         ↓
   Model     Model     Model
```

## API 설계 가이드

### RESTful API 원칙
- 리소스 중심 URL 설계
- HTTP 메서드 적절히 활용 (GET, POST, PUT, DELETE)
- 상태 코드 표준 준수

### 응답 형식
```json
{
  "success": true,
  "data": {
    // 실제 응답 데이터
  },
  "error": null,
  "timestamp": "2024-01-01T00:00:00"
}
```

### 에러 응답
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "사용자를 찾을 수 없습니다."
  },
  "timestamp": "2024-01-01T00:00:00"
}
```

## 데이터베이스 설계

### MyBatis 사용 지침
- Mapper 인터페이스 + XML 방식 사용
- 동적 SQL은 XML에서 처리
- 복잡한 조인은 ResultMap 활용

### 테이블 명명 규칙
- 스네이크 케이스 사용: `user_info`, `schedule_item`
- 복수형 지양, 단수형 사용
- 접두사로 도메인 표시 가능: `sch_calendar`

### 공통 필드
모든 테이블에 포함되는 필드:
- `id`: Primary Key (BIGINT)
- `created_at`: 생성일시
- `created_by`: 생성자
- `updated_at`: 수정일시
- `updated_by`: 수정자
- `deleted_at`: 삭제일시 (Soft Delete)

## 보안 고려사항

### 인증/인가
- JWT 토큰 기반 인증
- Spring Security 활용
- 역할 기반 접근 제어 (RBAC)

### 데이터 보호
- 민감정보 암호화 저장
- SQL Injection 방지 (Prepared Statement)
- XSS 방지 (입력값 검증)

## 확장성 고려사항

### 향후 JPA 마이그레이션
- Entity 클래스는 JPA 어노테이션 호환 가능하도록 설계
- Repository 패턴 도입 고려
- QueryDSL 도입 가능성 염두

### 이벤트 기반 아키텍처
- 서비스 간 비동기 통신
- Kafka/Redis Pub-Sub 도입 준비
- 이벤트 소싱 패턴 적용 가능

### API Gateway
- 단일 진입점 제공
- 라우팅 및 로드밸런싱
- 인증/인가 중앙화